# 蓝牙广播

本文介绍如何开启广播，设置广播数据，以及广播数据的含义。示例代码中仅仅做了广播数据的演示，没有实现扫描响应和可连接，请读者阅读此文后自行实现扫描响应。

## 操作步骤
- 在本目录下执行```make```指令编译固件
- 将开发板通过USB线缆连接到计算机，设置好串口号后执行```make flash```指令烧录固件
- 烧录完成后执行```make monitor```指令运行固件

## 代码解析

程序主要通过```app.c```文件中的```user_init_normal(void)```函数中实现蓝牙初始化，主要代码如下：


	blc_ll_initBasicMCU();   //初始化MCU

	blc_ll_initStandby_module(mac_public);		//初始化蓝牙待机功能模块

	blc_ll_initAdvertising_module(mac_public);  //初始化蓝牙广播功能模块

	u8 tbl_advData[] = { 0x05, 0x09, 'A', 'B', 'C', 'D'}; //要广播的数据

	bls_ll_setAdvData( (u8 *)tbl_advData, sizeof(tbl_advData) );

	u8 status = bls_ll_setAdvParam( ADV_INTERVAL_500MS , //广播时间间隔最小值
									ADV_INTERVAL_500MS , //广播时间间隔最大值
									ADV_TYPE_NONCONNECTABLE_UNDIRECTED, //广播类型，不可连接非定向
									OWN_ADDRESS_PUBLIC, //自身地址类型
									0,  //定向地址类型
									NULL, //定向地址
									BLT_ENABLE_ADV_ALL, //在全部广播信道(37,38,39)都广播数据
									ADV_FP_NONE);//过滤策略

	if(status != BLE_SUCCESS)//如果设置广播参数失败
	{
		write_reg8(0x40000, 0x11);  //debug
		while(1);
	}

	rf_set_power_level_index (MY_RF_POWER_INDEX); //设置发射功率

	bls_ll_setAdvEnable(1);  //开启广播

示例代码设置的广播数据为```ABCD```,打开蓝牙助手手机APP，可以搜索到名称为```ABCD```设备。

## 修改广播数据内容

如代码所示，广播数据存放在数组tbl_advData中，其中第一个字节是余下广播数据的长度，第二个字节是广播数据类型(0x09代表设别名称)，将其修改为如下数据，则可以在手机APP上搜索到名称为```ABCDEFG```设备。

    u8 tbl_advData[] = { 0x08, 0x09, 'A', 'B', 'C', 'D', 'E', 'F', 'G'}; //要广播的数据

关于蓝牙数据宝结构和蓝牙广播数据类型，请参考下表。

以上示例只在蓝牙广播数据中设置了蓝牙设备名称，实际上蓝牙广播包中可以包含多个广播类型的数据。比如可以将双播数据包更改为如下形式：

    u8 tbl_advData[] = {
        0x08, 0x09, 'A', 'B', 'C', 'D', 'E', 'F', 'G', //设备名称
        0x03, 0x19, 0x80, 0x01,  //设备外观
        }; //要广播的数据

## 蓝牙广播数据包结构

蓝牙广播数据包格式如下：
|Length|AD Type|AD Date|
|------|-------|-------|
|广播数据长度|广播数据类型|广播数据内容|

每个字段的含义如下：

- Length表示有效数据的长度，最大为0x1E(31);
- AD Type表示广播数据的类型，此字段非常重要，决定广播包的含义
- AD Date 广播数据内容，最多29字节(Length和AD Type个占一个字节)

每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分，如果有效数据部分不到 31 自己，剩下的就用 0 补全(一般由协议栈字自动不全)。

### 蓝牙广播数据类型定义：

|AD Type|含义|备注|
|-------|----|----|
|0x01|广播模式
|0x02|非完整的 16 bit UUID 列表
|0x03|完整的 16 bit UUID 列表
|0x04|非完整的 32 bit UUID 列表
|0x05|完整的 32 bit UUID 列表
|0x06|非完整的 128 bit UUID 列表
|0x07|完整的 128 bit UUID 列表
|0x08|缩写的设备名称
|0x09|完整的设备名称
|0x0A|广播包的信号强度
|0x0B|
|0x0C|
|0x0D|
|0x0E|
|0x0F|
|0x10|
|0x11|带外安全管理
|0x12|(Slave)连接间隔范围
|0x13|
|0x14|16 bit UUID 列表
|0x15|128 bit UUID 列表
|0x16|16 bit UUID Service|前 2 字节是 UUID，后面是 Service 的数据
|0x17|公开目标地址
|0x18|随机目标地址
|0x19|Appearance(外观)
|0x1A|
|0x1B|
|0x1C|
|0x1D|
|0x1E|
|0x1F|
|0x20|32 bit UUID Service|前 4 字节是 UUID，后面是 Service 的数据
|0x21|128 bit UUID Service|前 16 字节是 UUID，后面是 Service 的数据
|~~~|
|0x29|PB-ADV|
|0x2A|Mesh Message|
|0x2B|Mesh Beacon|
|~~~|
|0xFF|厂商自定义数据

## 修改广播参数

通过 ```bls_ll_setAdvParam()``` 函数可以修改广播参数，主要的广播参数有 ```广播时间间隔```， ```广播类型```， ```地址类型```， ```广播信道```等等。

### 广播时间间隔(Advertising interval)
除了定向报文以外，其他广播事件均可以选择“20ms ~ 10.28s”不等的间隔。通常，一个广播中的设备会每一秒广播一次。两个相邻广播事件之间的时间称为广播间隔。

但是，设备周期性的发送广播会有一个问题：由于设备间的时钟会不同程度的漂移，两个设备可能在很长一段时间同时广播而造成干扰。为防止这一情况的发生，除定向广播之外的其他广播类型，发送时间均会被扰动。实现该扰动的方式为，在上一次广播事件后加入“0 ~ 10ms”的随机延时。这意味着，即使两个设备广播间隔相同，并在相同信道及时间点上发送造成了冲突，但它们发送下一个广播事件时也会有很大可能不再冲突。

所以设置广播参数时，需设置广播时间间隔的最大值和最小值。

### 广播类型(Advertising_Type)

广播的类型一般分为四种，分别是：

|类性值|类型描述|
|------|-------|
|0x00  |可连接的非定向广播(Connectable Undirected Event Type)|
|0x01  |可连接的定向广播(Connectable Directed Event Type)|
|0x02  |不可连接的非定向广播(Non-connectable Undirected Event Type)|
|0x03  |可扫描的非定向广播(Scannable Undirected Event Type)|

1.可连接的非定向广播（Connectable Undirected Event Type）。这是一种用途最广的广播类型，包括广播数据和扫描响应数据，它表示当前设备可以接受其他任何设备的连接请求。

2.可连接的定向广播（Connectable Directed Event Type）。定向广播类型是为了尽可能快的建立连接。这种报文包含两个地址：广播者的地址和发起者的地址。发起者收到发给自己的定向广播报文之后，可以立即发送连接请求作为回应。

定向广播类型有特殊的时序要求。完整的广播事件必须每3.75ms重复一次。这一要求使得扫描设备只需扫描3.75ms便可以收到定向广播设备的消息。

当然，如此快的发送会让报文充斥着广播信道，进而导致该区域内的其他设备无法进行广播。因此，定向广播不可以持续1.28s以上的时间。如果主机没有主动要求停止，或者连接没有建立，控制器都会自动停止广播。一旦到了1.28s，主机便只能使用间隔长得多的可连接非定向广播让其他设备来连接。

当使用定向广播时，设备不能被主动扫描。此外，定向广播报文的净荷中也不能带有其他附加数据。该净荷只能包含两个必须的地址。

3.不可连接的非定向广播（Non-connectable Undirected Event Type）。仅仅发送广播数据。

4.可扫描的非定向广播（Scannable Undirected Event Type）。这种广播不能用于发起连接，但允许其他设备扫描该广播设备。这意味着该设备可以被发现，既可以发送广播数据，也可以响应扫描发送扫描回应数据，但不能建立连接。这是一种适用于广播数据的广播形式，动态数据可以包含于广播数据之中，而静态数据可以包含于扫描响应数据之中。

注意：所谓的定向和非定向针对的是广播的对象，如果是针对特定的对象进行广播（在广播包PDU中会包含目标对象的MAC）就是定向广播，反之就是非定向。可连接和不可连接是指是否接受连接请求，如果是不可连接的广播类型，它将不回应连接请求。可扫描广播类型是指回应扫描请求。

不同的广播类型对扫描请求和连接请求的支持如下表：

|广播类型|扫描请求|连接请求|
|--------|-------|-------|
|可连接的非定向广播|支持|支持|
|可连接的定向广播|不支持|支持|
|不可连接的非定向广播|不支持|不支持|
|可扫描的非定向广播|支持|不支持

### 自身地址类型(Own_Address_Type)
设备自身地址类型共有两种：

|类性值|类型描述|
|------|-------|
|0x00  | 公有设备地址(Public Device Addrss)|
|0x01  |随机设备地址(Ramdom Device Address)|

Public Device Addrss：公有设备地址是设备所特有的并且是不可改变的。类似网络设备的MAC地址，它的长度为48位。

Ramdom Device Address：随机设备地址（私有设备地址），它也是48位。

### 定向地址类型(Direct_Address_Type)
地址类型同Own_Address_Type类似，非定向广播无需设置定向地址。

### 广播信道(Advertising_Channel_Map)

蓝牙设备默认有三个广播信道，分别是37,38,39。在一个广播事件中，一个广播包会依次在每个信道上进行传输。

### 广播过滤策略(Advertising_Filter_Policy)

过滤策略可以过滤掉一些连接请求和扫描请求，策略定义如下：

|策略值|策略描述|
|-----|--------|
|0x00|接受任何设备的扫描请求或连接请求|
|0x01|仅仅接受白名单中的特定设备的扫描请求，但是接受任何设备的连接请求|
|0x02|接受任何设备的扫描请求，但仅仅接受白名单中的特定设备的连接请求|
|0x03|仅仅接受白名单中的特定设备的扫描请求和连接请求|

## 设置发射功率

通过 ```rf_set_power_level_index()```函数可以设置发射功率，按照相关规定，蓝牙的最大发射功率为10dBm，一般情况下，蓝牙广播的发射功率设置为0dBm。